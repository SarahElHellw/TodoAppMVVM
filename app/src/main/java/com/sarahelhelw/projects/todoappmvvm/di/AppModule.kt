package com.sarahelhelw.projects.todoappmvvm.di

import android.app.Application
import androidx.room.Room
import com.sarahelhelw.projects.todoappmvvm.data.room.TaskDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.SupervisorJob
import javax.inject.Qualifier
import javax.inject.Singleton

@Module //Declares a class as a Hilt Module(contains methods that provide dependencies)
//tells dagger in what scope do we need this object  SingletonComponent means in the scope of the application
//the dependencies in this module will be created in the Application's onCreate() method and
//destroyed when the application is destroyed
@InstallIn(SingletonComponent::class) //@InstallIn tells hilt in which scope these dependencies should be defined
//SingletonComponent is an autogenerated class by Hilt
object AppModule {

    @Provides
    @Singleton //creates a single instance of that database
    fun provideTaskDatabase(
        application: Application,
        callback: TaskDatabase.Callback
    ): TaskDatabase =
        Room.databaseBuilder(application, TaskDatabase::class.java, "tasks_database")
            .fallbackToDestructiveMigration()
            .addCallback(callback) // this callback is called when the database is created for the first time
            .build()

    @Provides
//    @Singleton -> not needed as Room already provides the dao instance as Singleton
    fun provideTaskDao(database: TaskDatabase) = database.taskDao()

    /**
     * This is how we declared a coroutine scope that lives
     * as long as our application lives because we declared
     * it as a Singleton in the SingletonComponent which lives through out the app
     */
    @ApplicationScope
    @Provides
    @Singleton
    fun provideApplicationScope() = CoroutineScope(SupervisorJob())

}

@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class ApplicationScope
